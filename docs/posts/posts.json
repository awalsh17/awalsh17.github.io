[
  {
    "path": "posts/2022-03-13-stacking-in-base-r/",
    "title": "Stacking vectors",
    "description": "Don't forget to use stack().",
    "author": [
      {
        "name": "Alice",
        "url": {}
      }
    ],
    "date": "2022-03-13",
    "categories": [],
    "contents": "\nIntro\nI have recently found a couple of great use cases for the stack() function from {utils}.\nBecause I want to remind my future self about this, I thought it would make a good short post to test this {distill} site that I just created!\nDocumentation\nFrom the stack() function documentation:\n\n“Stacking vectors concatenates multiple vectors into a single vector along with a factor indicating where each > observation originated. Unstacking reverses this operation.”\n\nAn example\nSometimes, I get a bunch of vectors. Maybe I had multiple files or outputs with various items in them that correspond to different groups. Often, I need to combine these and then check how many of the items exist across multiple groups.\nFor the purpose of illustration, here I will pretend that I read into R a set of gene names as a named list.\n\n\nmy_list <- list(test1 = c(\"KRAS\",\"EGFR\",\"ERBB2\"),\n                test2 = c(\"ERBB2\",\"ERBB3\",\"SPRY2\",\"AR\"),\n                test3 = c(\"APC\",\"BRAF\"))\n\n\n\nstack() makes a nice tidy data.frame! (Note that this would also work if the input was a nested list of lists.)\n\n\nstack(my_list)\n\n\n  values   ind\n1   KRAS test1\n2   EGFR test1\n3  ERBB2 test1\n4  ERBB2 test2\n5  ERBB3 test2\n6  SPRY2 test2\n7     AR test2\n8    APC test3\n9   BRAF test3\n\nIf you table() the result from stack(), now you have a nice matrix of the values in each group.\n\n\ntable(stack(my_list))\n\n\n       ind\nvalues  test1 test2 test3\n  APC       0     0     1\n  AR        0     1     0\n  BRAF      0     0     1\n  EGFR      1     0     0\n  ERBB2     1     1     0\n  ERBB3     0     1     0\n  KRAS      1     0     0\n  SPRY2     0     1     0\n\nThe resulting object is a table. You can convert it to a data.frame.\n\n\nas.data.frame.array(table(stack(my_list)))\n\n\n      test1 test2 test3\nAPC       0     0     1\nAR        0     1     0\nBRAF      0     0     1\nEGFR      1     0     0\nERBB2     1     1     0\nERBB3     0     1     0\nKRAS      1     0     0\nSPRY2     0     1     0\n\nYou can also convert the binary matrix to logical (TRUE/FALSE).\n\n\ntable(stack(my_list)) > 0\n\n\n       ind\nvalues  test1 test2 test3\n  APC   FALSE FALSE  TRUE\n  AR    FALSE  TRUE FALSE\n  BRAF  FALSE FALSE  TRUE\n  EGFR   TRUE FALSE FALSE\n  ERBB2  TRUE  TRUE FALSE\n  ERBB3 FALSE  TRUE FALSE\n  KRAS   TRUE FALSE FALSE\n  SPRY2 FALSE  TRUE FALSE\n\nNow, imagine a case where you have the table and some values are greater than 1 (because they appeared in a list more than once). You can use a trick to convert to logical and back to numeric 0/1.\n\n\nmy_list_w_repeats <- list(\n  test1 = c(\"KRAS\",\"EGFR\",\"ERBB2\"),\n  test2 = c(\"ERBB2\",\"ERBB3\",\"SPRY2\",\"AR\"),\n  test3 = c(\"APC\",\"APC\",\"APC\",\"BRAF\")) # APC is here 3 times\n\ntable(stack(my_list_w_repeats))\n\n\n       ind\nvalues  test1 test2 test3\n  APC       0     0     3\n  AR        0     1     0\n  BRAF      0     0     1\n  EGFR      1     0     0\n  ERBB2     1     1     0\n  ERBB3     0     1     0\n  KRAS      1     0     0\n  SPRY2     0     1     0\n\n+(table(stack(my_list_w_repeats)) > 0)\n\n\n       ind\nvalues  test1 test2 test3\n  APC       0     0     1\n  AR        0     1     0\n  BRAF      0     0     1\n  EGFR      1     0     0\n  ERBB2     1     1     0\n  ERBB3     0     1     0\n  KRAS      1     0     0\n  SPRY2     0     1     0\n\nSummary\nI forget about this function every once in a while and it is really useful. I also have a gist about this.\nFor fun, here is one way to do this with {dplyr} and {tidyr}. I would like to hear about other ways because I don’t find this as intuitive.\n\n\nlibrary(dplyr, quietly = TRUE)\n\nlapply(my_list, function(x) data.frame(genes = x)) %>% \n  bind_rows(.id = \"names\")\n\n\n  names genes\n1 test1  KRAS\n2 test1  EGFR\n3 test1 ERBB2\n4 test2 ERBB2\n5 test2 ERBB3\n6 test2 SPRY2\n7 test2    AR\n8 test3   APC\n9 test3  BRAF\n\nNow to make the binary matrix.\n\n\nlapply(my_list, function(x) data.frame(genes = x)) %>% \n  bind_rows(.id = \"names\") %>%\n  count(names, genes) %>%\n  tidyr::pivot_wider(names_from = \"names\",\n                     values_from = \"n\",\n                     values_fill = 0)\n\n\n# A tibble: 8 x 4\n  genes test1 test2 test3\n  <chr> <int> <int> <int>\n1 EGFR      1     0     0\n2 ERBB2     1     1     0\n3 KRAS      1     0     0\n4 AR        0     1     0\n5 ERBB3     0     1     0\n6 SPRY2     0     1     0\n7 APC       0     0     1\n8 BRAF      0     0     1\n\n\n\n\n",
    "preview": {},
    "last_modified": "2022-03-13T14:36:20-04:00",
    "input_file": {}
  },
  {
    "path": "posts/welcome/",
    "title": "Welcome to the test site",
    "description": "This is a test post.",
    "author": [
      {
        "name": "Alice",
        "url": {}
      }
    ],
    "date": "2022-03-13",
    "categories": [],
    "contents": "\nThis is a test post. Not much to see here.\n\n\n\n",
    "preview": {},
    "last_modified": "2022-03-13T13:17:52-04:00",
    "input_file": {}
  }
]
