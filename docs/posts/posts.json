[
  {
    "path": "posts/2022-03-20-more-models/",
    "title": "Testing many models with grouped data",
    "description": "Another example of something I do a lot and forget how to do.",
    "author": [
      {
        "name": "Alice",
        "url": {}
      }
    ],
    "date": "2022-03-20",
    "categories": [],
    "contents": "\n\nContents\nMany models!\nAn example: penguin linear models\nAnother example: survival models\nsessionInfo\n\n\n\nMany models!\nI often have a situation where I am testing many hypotheses.\nHow I tested many models in R in the past was to use lapply or a loop. I don’t think there is any problem with that approach, I just really like using a pattern these days with grouped data using tidyverse packages.\nThe general pattern is\nMake the data long (if not already long)\nGroup and nest\nMutate to calculate your statistics\nUn-nest, filter, or select to get your desired output\n There is a great vignette on this topic from the {broom} package.\n\nAnother day, I will add a post on operations on pairwise combinations of variables ala the {corrr} package.\nFirst, load some packages.\n\n\nlibrary(tidyr, quietly = TRUE) # manipulating data and nesting\nlibrary(dplyr, quietly = TRUE) # general data and piping\nlibrary(purrr, quietly = TRUE) # i will use purrr::map\nlibrary(broom)                 # very good at reformatting model objects\nlibrary(palmerpenguins)        # for more fun data\nlibrary(survival)              # for time to event models\nlibrary(ggplot2)               # to make our plots\ntheme_set(theme_minimal(base_family = \"Avenir\")) # for plot appearance\n\n\n\nAn example: penguin linear models\nLet’s say we are interested in the association between all the numeric variables in the {palmerpenguins} penguin dataset and the species.\nIf you are not familiar with this dataset, the three penguin species have different features like bill depth, bill length, body mass, and flipper length.\n\n\nhead(penguins, 4)\n\n\n# A tibble: 4 x 8\n  species island    bill_length_mm bill_depth_mm flipper_length_mm\n  <fct>   <fct>              <dbl>         <dbl>             <int>\n1 Adelie  Torgersen           39.1          18.7               181\n2 Adelie  Torgersen           39.5          17.4               186\n3 Adelie  Torgersen           40.3          18                 195\n4 Adelie  Torgersen           NA            NA                  NA\n# … with 3 more variables: body_mass_g <int>, sex <fct>, year <int>\n\nHere, we can see that Gentoo are some big penguins and that Adelie has shorter bill length.\n\n\nShow code\n\npenguins %>% \n  pivot_longer(cols = where(is.numeric)) %>% \n  mutate(name = stringr::str_replace_all(name, \"_\", \" \"),\n         name = stringr::str_wrap(name, width = 10)) %>%\n  ggplot(aes(x = species, y = value, fill = species)) + \n  geom_boxplot() + \n  scale_fill_manual(values = c(\"#0E89BA\",\"#85BAA1\",\"#C16E70\")) +\n  facet_wrap(~name, scales = \"free\", nrow = 1) + \n  labs(title = \"The penguin species are different\",\n       x = NULL) +\n  theme(\n    legend.position = \"none\",\n    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)\n  )\n\n\n\n\nAs a reminder, I will follow the same general pattern above\nMake the data long - pivot all the numeric variables\nGroup and nest - group by the variable name\nMutate to calculate your statistics - variable ~ species\nUn-nest, filter, or select to get your desired output\n Below, I calculated p-values and R-squared values using\nstats::lm()\nstats::anova()\nbroom::tidy()\n\nNote that you could also use broom::glance() to get R-squared\n\n\npenguins %>% \n  # tidyr functions to select all the numeric columns and \n  # create a `name` and `value` column\n  pivot_longer(cols = where(is.numeric)) %>% \n  group_by(name) %>% \n  # tidyr::nest to create a data frame where each level of the \n  # grouped variable has a single row, and all the other\n  # rows and columns are now in a single nested column, `data`\n  nest() %>% \n  # use purrr::map to create new nested columns with the objects\n  # returned from `lm`, `anova`, `broom::tidy`\n  mutate(lm_fit = map(data, \n                      ~ lm(value ~ species, data = .x)),\n         r2 = map_dbl(lm_fit, ~summary(.x)$r.squared),\n         anova = map(lm_fit, anova),\n         tidied = map(anova, tidy)) %>% \n  unnest(tidied) %>%\n  # this filter removes the rows with \"Residuals\"\n  filter(term == \"species\") %>%\n  select(-data, -lm_fit, -anova) %>% \n  knitr::kable(digits = 3)\n\n\nname\nr2\nterm\ndf\nsumsq\nmeansq\nstatistic\np.value\nbill_length_mm\n0.708\nspecies\n2\n7.194317e+03\n3597.159\n410.600\n0.00\nbill_depth_mm\n0.680\nspecies\n2\n9.039670e+02\n451.984\n359.789\n0.00\nflipper_length_mm\n0.778\nspecies\n2\n5.247328e+04\n26236.642\n594.802\n0.00\nbody_mass_g\n0.670\nspecies\n2\n1.468642e+08\n73432107.078\n343.626\n0.00\nyear\n0.003\nspecies\n2\n6.010000e-01\n0.300\n0.447\n0.64\n\nWe could also do this with group_modify in dplyr.\nFrom the documentation:\n\ngroup_map(), group_modify() and group_walk() are purrr-style functions that can be used to iterate on grouped tibbles.\n\n\n\npenguins %>% \n  pivot_longer(cols = where(is.numeric)) %>% \n  group_by(name) %>% \n  # there is a litle extra work here to return r.squared\n  # group_modify needs the returned value to be a data.frame!\n  # so you need to create one\n  group_modify( ~tidy(anova(lm(value ~ species, data = .))),\n                ~tibble(summary(lm(value ~ species, data = .))$r.squared,\n                        .name_repair = ~ c(\"r2\")) ) %>%\n  # this filter removes the rows with \"Residuals\"\n  filter(term == \"species\") %>%\n  knitr::kable(digits = 3)\n\n\nname\nterm\ndf\nsumsq\nmeansq\nstatistic\np.value\nbill_depth_mm\nspecies\n2\n9.039670e+02\n451.984\n359.789\n0.00\nbill_length_mm\nspecies\n2\n7.194317e+03\n3597.159\n410.600\n0.00\nbody_mass_g\nspecies\n2\n1.468642e+08\n73432107.078\n343.626\n0.00\nflipper_length_mm\nspecies\n2\n5.247328e+04\n26236.642\n594.802\n0.00\nyear\nspecies\n2\n6.010000e-01\n0.300\n0.447\n0.64\n\nAnother example: survival models\nI often work with time to event models (survival models). You can also follow this same pattern.\nTake for example the survival::lung dataset that has some variables like age, sex, performance status (ECOG and Karnofsky), etc.\n\n\nglimpse(lung)\n\n\nRows: 228\nColumns: 10\n$ inst      <dbl> 3, 3, 3, 5, 1, 12, 7, 11, 1, 7, 6, 16, 11, 21, 12,…\n$ time      <dbl> 306, 455, 1010, 210, 883, 1022, 310, 361, 218, 166…\n$ status    <dbl> 2, 2, 1, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,…\n$ age       <dbl> 74, 68, 56, 57, 60, 74, 68, 71, 53, 61, 57, 68, 68…\n$ sex       <dbl> 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 2, 2, 1, 1, 1, 1,…\n$ ph.ecog   <dbl> 1, 0, 0, 1, 0, 1, 2, 2, 1, 2, 1, 2, 1, NA, 1, 1, 1…\n$ ph.karno  <dbl> 90, 90, 90, 90, 100, 50, 70, 60, 70, 70, 80, 70, 9…\n$ pat.karno <dbl> 100, 90, 90, 60, 90, 80, 60, 80, 80, 70, 80, 70, 9…\n$ meal.cal  <dbl> 1175, 1225, NA, 1150, NA, 513, 384, 538, 825, 271,…\n$ wt.loss   <dbl> NA, 15, 15, 11, 0, 0, 10, 1, 16, 34, 27, 23, 5, 32…\n\nWe can repeat the same pattern to test cox proportional hazards models for these variables individually in univariate models.\n\n\nlung %>% \n  # tidyr to make the data long\n  pivot_longer(cols = -c(status, time)) %>% \n  group_by(name) %>% \n  # group the data\n  nest() %>% \n  # use purrr::map to create new nested columns with the objects\n  mutate(cox_fit = map(data, \n                      ~ coxph(Surv(time, status) ~ value, data = .x)),\n         tidied = map(cox_fit, tidy, conf.int = TRUE)) %>% \n  unnest(tidied) %>% \n  select(-data, -cox_fit) %>% \n  knitr::kable(digits = 3)\n\n\nname\nterm\nestimate\nstd.error\nstatistic\np.value\nconf.low\nconf.high\ninst\nvalue\n-0.010\n0.010\n-0.942\n0.346\n-0.030\n0.010\nage\nvalue\n0.019\n0.009\n2.035\n0.042\n0.001\n0.037\nsex\nvalue\n-0.531\n0.167\n-3.176\n0.001\n-0.859\n-0.203\nph.ecog\nvalue\n0.476\n0.113\n4.198\n0.000\n0.254\n0.698\nph.karno\nvalue\n-0.016\n0.006\n-2.810\n0.005\n-0.028\n-0.005\npat.karno\nvalue\n-0.020\n0.005\n-3.631\n0.000\n-0.031\n-0.009\nmeal.cal\nvalue\n0.000\n0.000\n-0.535\n0.593\n-0.001\n0.000\nwt.loss\nvalue\n0.001\n0.006\n0.217\n0.828\n-0.011\n0.013\n\n\nYou could easily add a mutate() here to calculate p-values adjusted for multiple comparisons.\nsessionInfo\n\n\npander::pander(sessionInfo())\n\n\nR version 4.0.5 (2021-03-31)\nPlatform: x86_64-apple-darwin17.0 (64-bit)\nlocale: en_US.UTF-8||en_US.UTF-8||en_US.UTF-8||C||en_US.UTF-8||en_US.UTF-8\nattached base packages: stats, graphics, grDevices, utils, datasets, methods and base\nother attached packages: ggplot2(v.3.3.5), survival(v.3.2-10), palmerpenguins(v.0.1.0), broom(v.0.7.6), purrr(v.0.3.4), dplyr(v.1.0.5) and tidyr(v.1.1.3)\nloaded via a namespace (and not attached): tidyselect(v.1.1.0), xfun(v.0.30), bslib(v.0.2.5.1), pander(v.0.6.3), splines(v.4.0.5), lattice(v.0.20-41), colorspace(v.2.0-0), vctrs(v.0.3.7), generics(v.0.1.0), htmltools(v.0.5.1.1), yaml(v.2.2.1), utf8(v.1.2.1), rlang(v.0.4.10), jquerylib(v.0.1.4), pillar(v.1.6.0), glue(v.1.4.2), withr(v.2.4.2), DBI(v.1.1.1), lifecycle(v.1.0.0), stringr(v.1.4.0), munsell(v.0.5.0), gtable(v.0.3.0), memoise(v.2.0.0), evaluate(v.0.14), labeling(v.0.4.2), knitr(v.1.37), fastmap(v.1.1.0), fansi(v.0.4.2), highr(v.0.9), Rcpp(v.1.0.7), backports(v.1.2.1), scales(v.1.1.1), cachem(v.1.0.5), jsonlite(v.1.7.2), farver(v.2.1.0), distill(v.1.3), digest(v.0.6.29), stringi(v.1.5.3), grid(v.4.0.5), cli(v.3.1.0), tools(v.4.0.5), magrittr(v.2.0.1), sass(v.0.4.0), tibble(v.3.1.0), crayon(v.1.4.1), pkgconfig(v.2.0.3), downlit(v.0.4.0), ellipsis(v.0.3.1), Matrix(v.1.3-2), assertthat(v.0.2.1), rmarkdown(v.2.11), rstudioapi(v.0.13), R6(v.2.5.0) and compiler(v.4.0.5)\n\n\n\n\n",
    "preview": "posts/2022-03-20-more-models/more-models_files/figure-html5/unnamed-chunk-3-1.png",
    "last_modified": "2022-03-21T12:13:08-04:00",
    "input_file": {}
  },
  {
    "path": "posts/2022-03-13-stacking-in-base-r/",
    "title": "Stacking vectors",
    "description": "Don't forget to use stack().",
    "author": [
      {
        "name": "Alice",
        "url": {}
      }
    ],
    "date": "2022-03-13",
    "categories": [],
    "contents": "\nIntro\nI have recently found a couple of great use cases for the stack() function from {utils}.\nBecause I want to remind my future self about this, I thought it would make a good short post to test this {distill} site that I just created!\nDocumentation\nFrom the stack() function documentation:\n\n“Stacking vectors concatenates multiple vectors into a single vector along with a factor indicating where each observation originated. Unstacking reverses this operation.”\n\nAn example\nSometimes, I get a bunch of vectors. Maybe I had multiple files or outputs with various items in them that correspond to different groups. Often, I need to combine these and then check how many of the items exist across multiple groups.\nFor the purpose of illustration, here I will pretend that I read into R a set of gene names as a named list.\n\n\nmy_list <- list(test1 = c(\"KRAS\",\"EGFR\",\"ERBB2\"),\n                test2 = c(\"ERBB2\",\"ERBB3\",\"SPRY2\",\"AR\"),\n                test3 = c(\"APC\",\"BRAF\"))\n\n\n\nstack() makes a nice tidy data.frame! (Note that this would also work if the input was a nested list of lists.)\n\n\nstack(my_list)\n\n\n  values   ind\n1   KRAS test1\n2   EGFR test1\n3  ERBB2 test1\n4  ERBB2 test2\n5  ERBB3 test2\n6  SPRY2 test2\n7     AR test2\n8    APC test3\n9   BRAF test3\n\nIf you table() the result from stack(), now you have a nice matrix of the values in each group.\n\n\ntable(stack(my_list))\n\n\n       ind\nvalues  test1 test2 test3\n  APC       0     0     1\n  AR        0     1     0\n  BRAF      0     0     1\n  EGFR      1     0     0\n  ERBB2     1     1     0\n  ERBB3     0     1     0\n  KRAS      1     0     0\n  SPRY2     0     1     0\n\nThe resulting object is a table. You can convert it to a data.frame.\n\n\nas.data.frame.array(table(stack(my_list)))\n\n\n      test1 test2 test3\nAPC       0     0     1\nAR        0     1     0\nBRAF      0     0     1\nEGFR      1     0     0\nERBB2     1     1     0\nERBB3     0     1     0\nKRAS      1     0     0\nSPRY2     0     1     0\n\nYou can also convert the binary matrix to logical (TRUE/FALSE).\n\n\ntable(stack(my_list)) > 0\n\n\n       ind\nvalues  test1 test2 test3\n  APC   FALSE FALSE  TRUE\n  AR    FALSE  TRUE FALSE\n  BRAF  FALSE FALSE  TRUE\n  EGFR   TRUE FALSE FALSE\n  ERBB2  TRUE  TRUE FALSE\n  ERBB3 FALSE  TRUE FALSE\n  KRAS   TRUE FALSE FALSE\n  SPRY2 FALSE  TRUE FALSE\n\nNow, imagine a case where you have the table and some values are greater than 1 (because they appeared in a list more than once). You can use a trick to convert to logical and back to numeric 0/1.\n\n\nmy_list_w_repeats <- list(\n  test1 = c(\"KRAS\",\"EGFR\",\"ERBB2\"),\n  test2 = c(\"ERBB2\",\"ERBB3\",\"SPRY2\",\"AR\"),\n  test3 = c(\"APC\",\"APC\",\"APC\",\"BRAF\")) # APC is here 3 times\n\ntable(stack(my_list_w_repeats))\n\n\n       ind\nvalues  test1 test2 test3\n  APC       0     0     3\n  AR        0     1     0\n  BRAF      0     0     1\n  EGFR      1     0     0\n  ERBB2     1     1     0\n  ERBB3     0     1     0\n  KRAS      1     0     0\n  SPRY2     0     1     0\n\n+(table(stack(my_list_w_repeats)) > 0)\n\n\n       ind\nvalues  test1 test2 test3\n  APC       0     0     1\n  AR        0     1     0\n  BRAF      0     0     1\n  EGFR      1     0     0\n  ERBB2     1     1     0\n  ERBB3     0     1     0\n  KRAS      1     0     0\n  SPRY2     0     1     0\n\nSummary\nI forget about this function every once in a while and it is really useful. I also have a gist about this.\nFor fun, here is one way to do this with {dplyr} and {tidyr}. I would like to hear about other ways because I don’t find this as intuitive.\n\n\nlibrary(dplyr, quietly = TRUE)\n\nlapply(my_list, function(x) data.frame(genes = x)) %>% \n  bind_rows(.id = \"names\")\n\n\n  names genes\n1 test1  KRAS\n2 test1  EGFR\n3 test1 ERBB2\n4 test2 ERBB2\n5 test2 ERBB3\n6 test2 SPRY2\n7 test2    AR\n8 test3   APC\n9 test3  BRAF\n\nNow to make the binary matrix.\n\n\nlapply(my_list, function(x) data.frame(genes = x)) %>% \n  bind_rows(.id = \"names\") %>%\n  count(names, genes) %>%\n  tidyr::pivot_wider(names_from = \"names\",\n                     values_from = \"n\",\n                     values_fill = 0)\n\n\n# A tibble: 8 x 4\n  genes test1 test2 test3\n  <chr> <int> <int> <int>\n1 EGFR      1     0     0\n2 ERBB2     1     1     0\n3 KRAS      1     0     0\n4 AR        0     1     0\n5 ERBB3     0     1     0\n6 SPRY2     0     1     0\n7 APC       0     0     1\n8 BRAF      0     0     1\n\nsessionInfo\n\n\nsessionInfo()\n\n\nR version 4.0.5 (2021-03-31)\nPlatform: x86_64-apple-darwin17.0 (64-bit)\nRunning under: macOS Big Sur 10.16\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.0/Resources/lib/libRblas.dylib\nLAPACK: /Library/Frameworks/R.framework/Versions/4.0/Resources/lib/libRlapack.dylib\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods  \n[7] base     \n\nother attached packages:\n[1] dplyr_1.0.5\n\nloaded via a namespace (and not attached):\n [1] rstudioapi_0.13   knitr_1.37        magrittr_2.0.1   \n [4] tidyselect_1.1.0  downlit_0.4.0     R6_2.5.0         \n [7] rlang_0.4.10      fastmap_1.1.0     fansi_0.4.2      \n[10] stringr_1.4.0     tools_4.0.5       xfun_0.30        \n[13] utf8_1.2.1        cli_3.1.0         DBI_1.1.1        \n[16] jquerylib_0.1.4   htmltools_0.5.1.1 ellipsis_0.3.1   \n[19] assertthat_0.2.1  yaml_2.2.1        digest_0.6.29    \n[22] tibble_3.1.0      lifecycle_1.0.0   crayon_1.4.1     \n[25] tidyr_1.1.3       purrr_0.3.4       sass_0.4.0       \n[28] vctrs_0.3.7       distill_1.3       memoise_2.0.0    \n[31] glue_1.4.2        cachem_1.0.5      evaluate_0.14    \n[34] rmarkdown_2.11    stringi_1.5.3     compiler_4.0.5   \n[37] bslib_0.2.5.1     pillar_1.6.0      generics_0.1.0   \n[40] jsonlite_1.7.2    pkgconfig_2.0.3  \n\n\n\n\n",
    "preview": {},
    "last_modified": "2022-03-21T12:15:07-04:00",
    "input_file": "stacking-in-base-r.knit.md"
  },
  {
    "path": "posts/welcome/",
    "title": "Welcome to the test site",
    "description": "This is a test post.",
    "author": [
      {
        "name": "Alice",
        "url": {}
      }
    ],
    "date": "2022-03-13",
    "categories": [],
    "contents": "\nThis is a test post. Not much to see here.\n\n\n\n",
    "preview": {},
    "last_modified": "2022-03-13T13:17:52-04:00",
    "input_file": {}
  }
]
